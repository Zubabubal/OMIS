"""
ReportController <<Facade>> из диаграммы контроллеров
C ReportContoller <<Facade>>
-dataRepo: iSensorRepo
+создатьКлиматическийОчет(период:String):Report
iSensorRepo->(использует)ReportContoller <<Facade>
"""

import logging
from datetime import datetime, timedelta
from typing import Dict, Any, List

from domain.models import ДанныеСенсора
from domain.repositories import ISensorRepo
from domain.reports import КлиматическийОтчет


class ReportController:
    """
    Фасад для создания отчетов
    C ReportContoller <<Facade>>
    """

    def __init__(self, data_repo: ISensorRepo):
        """
        Конструктор получает iSensorRepo через DI
        -dataRepo: iSensorRepo
        """
        self.data_repo = data_repo
        self.logger = logging.getLogger(__name__)

    async def создатьКлиматическийОтчет(self, период: str) -> КлиматическийОтчет:
        """+создатьКлиматическийОчет(период:String):Report"""
        self.logger.info(f"Создание климатического отчета за период: {период}")

        # Определение временного диапазона по периоду
        начало, конец = self._определитьПериод(период)

        # Получение данных за период
        данные = self.data_repo.получитьЗаПериод(начало, конец)

        if not данные:
            return КлиматическийОтчет(
                период=период,
                данных=0,
                сообщение="Нет данных за указанный период"
            )

        # Анализ данных
        анализ = self._проанализироватьДанные(данные)

        # Создание отчета
        отчет = КлиматическийОтчет(
            период=период,
            данных=len(данные),
            временной_диапазон={
                "начало": datetime.fromtimestamp(начало / 1000).isoformat(),
                "конец": datetime.fromtimestamp(конец / 1000).isoformat()
            },
            анализ=анализ,
            рекомендации=self._сгенерироватьРекомендации(анализ)
        )

        return отчет

    def _определитьПериод(self, период: str) -> tuple[int, int]:
        """Определение временного диапазона по строке периода"""
        сейчас = int(datetime.now().timestamp() * 1000)

        периоды = {
            "сутки": 24 * 3600 * 1000,
            "неделя": 7 * 24 * 3600 * 1000,
            "месяц": 30 * 24 * 3600 * 1000,
            "квартал": 90 * 24 * 3600 * 1000,
            "год": 365 * 24 * 3600 * 1000
        }

        if период in периоды:
            начало = сейчас - периоды[период]
        else:
            начало = сейчас - периоды["сутки"]

        return начало, сейчас

    def _проанализироватьДанные(self, данные: List[ДанныеСенсора]) -> Dict[str, Any]:
        """Анализ климатических данных"""
        анализ = {
            "температура": {},
            "влажность": {},
            "давление": {},
            "ветер": {},
            "осадки": {}
        }

        # Группировка по типам
        данные_по_типам: Dict[str, List[float]] = {}
        for запись in данные:
            if запись.типИзмерения not in данные_по_типам:
                данные_по_типам[запись.типИзмерения] = []
            данные_по_типам[запись.типИзмерения].append(запись.значение)

        # Статистика для каждого типа
        for тип, значения in данные_по_типам.items():
            if значения:
                ключ = self._маппингТипа(тип)
                if ключ in анализ:
                    анализ[ключ] = {
                        "среднее": sum(значения) / len(значения),
                        "минимум": min(значения),
                        "максимум": max(значения),
                        "количество": len(значения)
                    }

        return анализ

    def _маппингТипа(self, тип: str) -> str:
        """Маппинг типа измерения на категорию анализа"""
        маппинг = {
            "temperature": "температура",
            "humidity": "влажность",
            "pressure": "давление",
            "wind_speed": "ветер",
            "precipitation": "осадки"
        }
        return маппинг.get(тип, "другое")

    def _сгенерироватьРекомендации(self, анализ: Dict[str, Any]) -> List[str]:
        """Генерация рекомендаций на основе анализа"""
        рекомендации = []

        if "температура" in анализ and "среднее" in анализ["температура"]:
            средняя_температура = анализ["температура"]["среднее"]
            if средняя_температура < 0:
                рекомендации.append("Возможны заморозки")
            elif средняя_температура > 25:
                рекомендации.append("Высокая температура")

        if "осадки" in анализ and "среднее" in анализ["осадки"]:
            средние_осадки = анализ["осадки"]["среднее"]
            if средние_осадки > 5:
                рекомендации.append("Высокие осадки")

        if not рекомендации:
            рекомендации.append("Условия в пределах нормы")

        return рекомендации